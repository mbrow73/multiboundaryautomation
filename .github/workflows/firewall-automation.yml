name:  Process Firewall Requests

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process:
    if: contains(github.event.issue.labels.*.name, 'firewall-request')
    runs-on: ubuntu-latest
    steps:

      - name: ⬇️ Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name:  Validate Issue Format and Data
        id: validate
        shell: bash
        run: |
          # write the issue body to disk
          echo "${{ github.event.issue.body }}" > issue.txt

          # ———————— duplicate-REQID guard ————————
          REQID=$(grep -i "Request ID" issue.txt | head -1 | cut -d: -f2- | xargs)
          if [ -f "firewall-requests/${REQID}.auto.tfvars.json" ]; then
            gh issue comment ${{ github.event.issue.number }} --body $'### ❌ Duplicate Request ID\n\nThe Request ID **'"${REQID}"'** has already been used for a firewall request. Please choose a new Request ID or submit an update request instead.'
            gh issue close ${{ github.event.issue.number }}
            exit 1
          fi
          # ————————————————————————————————

          # run validator
          set +e
          python3 .github/scripts/firewall_request_validator.py issue.txt > validation_output.txt
          STATUS=$?
          set -e
          if [ "$STATUS" -ne 0 ]; then
            ERRORS=$(awk '/VALIDATION_ERRORS_START/,/VALIDATION_ERRORS_END/' validation_output.txt \
                     | sed '/VALIDATION_ERRORS_START\|VALIDATION_ERRORS_END/d')
            gh issue comment ${{ github.event.issue.number }} --body $'### ❌ Firewall Request Validation Failed\n\n**Errors:**\n\n'"$(echo "$ERRORS" | sed 's/^/- /')"'\n\n_Your request was closed. Please correct the above and submit again._'
            gh issue close ${{ github.event.issue.number }}
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name:  Determine current max priority
        id: max_priority
        shell: bash
        run: |
          mkdir -p firewall-requests
          if compgen -G "firewall-requests/*.auto.tfvars.json" > /dev/null; then
            MAX=$(jq -s '[ .[].auto_firewall_rules[].priority // empty ] | max // 999' firewall-requests/*.auto.tfvars.json)
          else
            MAX=999
          fi
          if [[ -z "$MAX" || "$MAX" == "null" ]]; then MAX=999; fi
          if [[ "$MAX" =~ ^[0-9]+$ ]] && [ "$MAX" -lt 1000 ]; then MAX=999; fi
          {
            echo "MAX_PRIORITY<<EOF"
            echo "$MAX"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name:  Parse Issue, Generate Per-REQID JSON and Rule Summary
        id: parse_and_write
        shell: bash
        run: |
          set -e

          ISSUE_BODY="$(printf '%s' "${{ github.event.issue.body }}" | tr -d $'\r' | sed -e 's/[\x00-\x1F]//g')"
          REQID=$(echo "$ISSUE_BODY" | grep -i "Request ID" | head -1 | cut -d: -f2- | xargs)
          CARID=$(echo "$ISSUE_BODY" | grep -i "CARID"     | head -1 | cut -d: -f2- | xargs)
          echo "REQID=$REQID" >> "$GITHUB_OUTPUT"

          MAX_PRIORITY=${{ steps.max_priority.outputs.MAX_PRIORITY }}

          # Detect mawk vs gawk and set sprintf room for mawk.
          if command -v mawk >/dev/null 2>&1 && ! command -v gawk >/dev/null 2>&1; then
            AWK_BIN="mawk"
            AWK_SPRINTF="-W sprintf=10485760"   # 10 MiB
          else
            # Prefer gawk if present (no sprintf limit). If only awk exists and is gawk, fine.
            AWK_BIN="$(command -v gawk || command -v awk)"
            AWK_SPRINTF=""
          fi

          # Write the awk programs to files (avoids quoting/eval issues).
          cat > split_rules.awk <<'AWK'
          BEGIN { rule=0 }
          /^####[[:space:]]*Rule/ {
            if (rule) { print rule_block "\n@@@" }
            rule_block=""; rule=1; next
          }
          rule { rule_block = rule_block $0 "\n" }
          END { if (rule) print rule_block }
          AWK

          cat > build_json.awk <<'AWK'
          function build_list(str,   arr, j, list) {
            gsub(/,[[:space:]]*/, ",", str)
            split(str, arr, ",")
            list=""
            for (j=1; j<=length(arr); j++) {
              gsub(/^[ \t]+|[ \t]+$/, "", arr[j])
              if (arr[j] != "") {
                if (list != "") list = list ","
                list = list "\"" arr[j] "\""
              }
            }
            return list
          }
          BEGIN { RS="@@@"; ORS=""; }
          NF {
            src=""; dst=""; ports=""; proto=""; dir=""; just="";
            svpc=""; dvpc="";
            n=split($0, lines, "\n")
            for (i=1; i<=n; i++) {
              line=lines[i]
              if (line ~ /New Source IP/)               { sub(/.*: */,"",line); gsub(/^[ \t]+|[ \t]+$/,"",line); src=line }
              else if (line ~ /New Destination IP/)     { sub(/.*: */,"",line); gsub(/^[ \t]+|[ \t]+$/,"",line); dst=line }
              else if (line ~ /New Port/)               { sub(/.*: */,"",line); gsub(/^[ \t]+|[ \t]+$/,"",line); ports=line }
              else if (line ~ /New Protocol/)           { sub(/.*: */,"",line); gsub(/^[ \t]+|[ \t]+$/,"",line); proto=line }
              else if (line ~ /New Direction/)          { sub(/.*: */,"",line); gsub(/^[ \t]+|[ \t]+$/,"",line); dir=line }
              else if (line ~ /New Business Justification/) { sub(/.*: */,"",line); gsub(/^[ \t]+|[ \t]+$/,"",line); just=line }
            }
            src_list  = build_list(src)
            dst_list  = build_list(dst)
            port_list = build_list(ports)

            ports_plain = ports
            gsub(/,[[:space:]]*/, ",", ports_plain)

            rulename = sprintf("AUTO-%s-%s-%s-%s-%d", reqid, carid, toupper(proto), ports_plain, NR)
            desc     = rulename " | " just

            printf("{\"name\":\"%s\",\"description\":\"%s\",\"direction\":\"%s\",\"src_vpc\":\"%s\",\"dest_vpc\":\"%s\",\"src_ip_ranges\":[%s],\"dest_ip_ranges\":[%s],\"ports\":[%s],\"protocol\":\"%s\",\"priority\":%d,\"enable_logging\":true}\n", \
                   rulename, desc, dir, svpc, dvpc, src_list, dst_list, port_list, tolower(proto), maxp+NR) >> "rules.json"

            rule_flow = sprintf("- **Rule %d:** %s → %s on %s/%s\n    Justification: %s\n", \
                                NR, src, dst, tolower(proto), ports_plain, just)
            print rule_flow >> "rules_summary.txt"
          }
          AWK

          # 1) Split the issue body into rule blocks
          printf '%s\n' "$ISSUE_BODY" | "$AWK_BIN" $AWK_SPRINTF -f split_rules.awk > rules_blocks.txt

          # 2) Build JSON and human summary from those blocks
          : > rules.json
          : > rules_summary.txt
          "$AWK_BIN" $AWK_SPRINTF -v carid="$CARID" -v reqid="$REQID" -v maxp="$MAX_PRIORITY" \
            -f build_json.awk rules_blocks.txt

          RULES_JSON=$(paste -sd, rules.json)
          TFVARS="{\"auto_firewall_rules\":[${RULES_JSON}]}"

          mkdir -p firewall-requests
          echo "$TFVARS" | jq '.' > "firewall-requests/${REQID}.auto.tfvars.json"

          SUMMARY=$(cat rules_summary.txt)
          {
            echo "RULE_SUMMARY<<EOF"
            echo "$SUMMARY"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: ️ Map IPs to Boundaries
        shell: bash
        run: |
          python3 .github/scripts/boundary_mapper.py \
            --map-file boundary_map.json \
            --json-file firewall-requests/${{ steps.parse_and_write.outputs.REQID }}.auto.tfvars.json \
            --default-boundary onprem

      - name: ⏫ Create or Update Pull Request for NetSec
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: |
            [Firewall Automation] Update rules for ${{ steps.parse_and_write.outputs.REQID }}
          branch: firewall/${{ steps.parse_and_write.outputs.REQID }}-${{ github.event.issue.number }}
          title: "Firewall request: ${{ steps.parse_and_write.outputs.REQID }} (Issue #${{ github.event.issue.number }})"
          body: |
            **Rule Flow Summary:**
            ${{ steps.parse_and_write.outputs.RULE_SUMMARY }}

            **Summary:**
            - Source: ${{ github.event.issue.user.login }}
            - Related Issue: #${{ github.event.issue.number }}

            **Rules:**  
            _See the file `firewall-requests/${{ steps.parse_and_write.outputs.REQID }}.auto.tfvars.json` for full details._

            > **NetSec:** Please review and merge if approved.

            Closes #${{ github.event.issue.number }}
          add-paths: |
            firewall-requests/${{ steps.parse_and_write.outputs.REQID }}.auto.tfvars.json
          base: main

      - name:  Comment PR Link to Issue
        if: steps.cpr.outputs.pull-request-url != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `:robot: PR [#${{ steps.cpr.outputs.pull-request-number }}](${{ steps.cpr.outputs.pull-request-url }}) opened/updated for NetSec review.`
            })
