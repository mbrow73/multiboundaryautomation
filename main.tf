locals {
  # Load manual firewall rules first (files with suffix .manual.auto.tfvars.json)
  manual_rules = flatten([
    for f in fileset(path.module, "*.manual.auto.tfvars.json") :
      jsondecode(file(f)).manual_firewall_rules
  ])

  # Load automated firewall rules generated by the automation scripts
  auto_rules = flatten([
    for f in fileset(path.module, "firewall-requests/*.auto.tfvars.json") :
      jsondecode(file(f)).auto_firewall_rules
  ])

  # Combine manual and automated rules into a single list
  all_rules = concat(local.manual_rules, local.auto_rules)

  # Build a distinct list of boundaries that have at least one rule.  For EGRESS rules the
  # rule is attached to its source boundary; for INGRESS rules it is attached to its
  # destination boundary.  This set is used to construct one policy per boundary.
  boundaries = distinct([
    for r in local.all_rules : r.direction == "EGRESS" ? r.src_boundary : r.dest_boundary
  ])

  # Assemble the per‑boundary policy configurations.  Each map entry contains the VPC
  # identifier, the policy name, and the list of firewall rules that belong to that
  # boundary.  The rules themselves contain src_boundary and dest_boundary fields,
  # allowing downstream logic to determine the correct attachment.  When computing the
  # rules for a given boundary we filter by the rule's attachment boundary as defined
  # above.
  boundary_policies = {
    for b in local.boundaries :
    b => {
      vpc_id        = var.boundary_vpcs[b]
      policy_name   = "${b}-policy"
      firewall_rules = [for r in local.all_rules : r if (r.direction == "EGRESS" ? r.src_boundary : r.dest_boundary) == b]
    }
  }
}

module "boundary_firewall_policy" {
  source                    = "./modules/boundary_firewall_policy"
  project_id                = var.project_id
  security_profile_group_id = var.security_profile_group_id
  boundary_policies         = local.boundary_policies
}

# Keep the original single‑policy module defined for backward compatibility.  It can be
# safely removed once all environments have migrated to the new boundary‑aware module.
# module "inet_firewall_policy" {
#   source                    = "./modules/firewall_policy"
#   project_id                = var.project_id
#   inet_vpc                  = var.boundary_vpcs["inet"]
#   security_profile_group_id = var.security_profile_group_id
#   policy_name               = "inet-policy"
#   inet_firewall_rules       = local.all_rules
# }